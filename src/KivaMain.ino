#include <Wire.h> 
#include "config.h"
#include "keyboard_layout.h" // Include for KeyboardLayer enum and layouts
#include "pcf_utils.h"
#include "input_handling.h"
#include "battery_monitor.h"
#include "ui_drawing.h"
#include "menu_logic.h"
#include "wifi_manager.h" // <--- ADDED
#include "sd_card_manager.h" // <--- ADDED

// ... (Bitmap Data) ...
#define im_width 128
#define im_height 64

static const unsigned char im_bits[] U8X8_PROGMEM = { // Added U8X8_PROGMEM to save RAM
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xe0,0x03,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xe0,0x0f,0x00,0x00,0x00,0x00,0xc0,0x1f,0x00,0x00,0x00,0x20,
0x00,0x00,0x00,0x00,0xe2,0x1f,0x00,0x00,0x00,0x00,0xf0,0x0f,0x18,0x00,0x00,
0x38,0x00,0x00,0x00,0x80,0xf1,0x1f,0x00,0x00,0x00,0x00,0xf8,0x07,0x1c,0x00,
0x00,0x3f,0x00,0x00,0x00,0xe0,0xf0,0x2f,0x00,0x00,0x00,0x00,0xfc,0x07,0x1e,
0x00,0x80,0x3f,0x00,0x00,0x00,0xf0,0xf0,0x27,0x00,0x00,0x00,0x00,0xfe,0x03,
0x1f,0x00,0x80,0x3f,0x00,0x00,0x00,0x7c,0xf0,0x47,0x00,0x00,0x00,0x00,0xff,
0x81,0x3f,0x00,0x80,0x3f,0x00,0x00,0x00,0x7f,0xf0,0xc7,0x00,0x00,0x00,0x80,
0xff,0xc0,0x3f,0x00,0x80,0x1f,0x00,0x00,0x80,0x3f,0xf8,0xc7,0x00,0x00,0x00,
0xc0,0x7f,0xe0,0x3f,0x00,0x80,0x1f,0x00,0x00,0xe0,0x3f,0xf8,0x83,0x01,0x00,
0x00,0xe0,0x3f,0xf0,0x7f,0x00,0xc0,0x1f,0x00,0x00,0xf8,0x1f,0xf8,0x83,0x03,
0x00,0x00,0xe0,0x1f,0xf8,0x7f,0x00,0xc0,0x1f,0x00,0x00,0xfe,0x1f,0xf8,0x03,
0x03,0x00,0x00,0xf0,0x0f,0xfc,0x7f,0x00,0xc0,0x1f,0x00,0x00,0xff,0x0f,0xf8,
0x03,0x07,0x00,0x00,0xf8,0x07,0xfe,0xfd,0x00,0xc0,0x1f,0x00,0xc0,0xff,0x07,
0xfc,0x03,0x0f,0x00,0x00,0xfc,0x03,0xff,0xfc,0x00,0xc0,0x1f,0x00,0xf0,0xff,
0x01,0xfc,0x01,0x0e,0x00,0x00,0xfe,0x83,0x7f,0xfc,0x00,0xe0,0x0f,0x00,0xfc,
0x7f,0x00,0xfc,0x01,0x1e,0x00,0x00,0xff,0xc1,0x3f,0xf8,0x01,0xe0,0x0f,0x00,
0xfe,0x1f,0x00,0xfc,0x01,0x3c,0x00,0x80,0xff,0xf0,0x1f,0xf8,0x01,0xe0,0x0f,
0x80,0xff,0x07,0x00,0xfc,0x01,0x3c,0x00,0xc0,0x7f,0xf8,0x0f,0xf8,0x01,0xe0,
0x0f,0xe0,0xff,0x01,0x00,0xfe,0x00,0x7c,0x00,0xe0,0x3f,0xfc,0x07,0xf8,0x03,
0xf0,0x0f,0xf0,0x7f,0x00,0x00,0xfe,0x00,0xf8,0x00,0xf0,0x1f,0xfe,0x03,0xf0,
0x03,0xf0,0x0f,0xfc,0x1f,0x00,0x00,0xfe,0x00,0xf8,0x00,0xf8,0x0f,0xff,0x01,
0xf0,0x03,0xf0,0x0f,0xff,0x07,0x00,0x00,0xfe,0x00,0xf8,0x01,0xfc,0x87,0xff,
0x00,0xf0,0x07,0xf0,0xcf,0xff,0x01,0x00,0x00,0xfe,0x00,0xf0,0x03,0xfe,0xc3,
0x7f,0x00,0xf0,0x07,0xf0,0xe7,0x7f,0x00,0x00,0x00,0x7f,0x00,0xf0,0x03,0xff,
0xe1,0x1f,0x00,0xe0,0x07,0xf8,0xff,0xff,0x01,0x00,0x00,0x7f,0x00,0xe0,0x87,
0xff,0xf1,0x0f,0x00,0xe0,0x07,0xf8,0xe7,0xff,0x07,0x00,0x00,0x7f,0x00,0xe0,
0xcf,0xff,0xf8,0x07,0x00,0xe0,0x0f,0xf8,0x07,0xff,0x0f,0x00,0x00,0x7f,0x00,
0xe0,0xef,0x7f,0xfc,0x03,0x00,0xe0,0x0f,0xf8,0x07,0xfc,0x3f,0x00,0x00,0x3f,
0x00,0xc0,0xff,0x3f,0xfe,0x01,0x00,0xc0,0x0f,0xf8,0x07,0xe0,0xff,0x00,0x80,
0x3f,0x00,0xc0,0xff,0x1f,0xff,0x00,0x00,0xfc,0x1f,0xfc,0x07,0x00,0xff,0x01,
0x80,0x3f,0x00,0x80,0xff,0xcf,0x7f,0xfe,0xff,0xc7,0x1f,0xfc,0x07,0x00,0xfc,
0x07,0x80,0x3f,0x00,0x80,0xff,0xe7,0xff,0xff,0xff,0xc0,0x1f,0xfc,0x03,0x00,
0xe0,0x1f,0x00,0x3f,0x00,0x80,0xff,0xe3,0xff,0xff,0x0f,0x80,0x3f,0xfe,0x03,
0x00,0x00,0x7f,0x00,0x1f,0x00,0x00,0xff,0xc1,0xff,0xff,0x01,0x80,0x3f,0xfe,
0x03,0x00,0x00,0xf8,0x00,0x1f,0x00,0x00,0xff,0x80,0xff,0x3f,0x00,0x80,0x3f,
0xfc,0x03,0x00,0x00,0xe0,0x03,0x1e,0x00,0x00,0xff,0x00,0xff,0x07,0x00,0x80,
0x3f,0xf8,0x03,0x00,0x00,0x00,0x0f,0x1e,0x00,0x00,0x7e,0x00,0xfe,0x00,0x00,
0x00,0x3f,0xe0,0x03,0x00,0x00,0x00,0x38,0x0e,0x00,0x00,0x3e,0x00,0x0c,0x00,
0x00,0x00,0x1f,0xc0,0x03,0x00,0x00,0x00,0xe0,0x0c,0x00,0x00,0x1c,0x00,0x00,
0x00,0x00,0x00,0x1f,0x00,0x01,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x0c,0x00,
0x00,0x00,0x00,0x00,0x0f,0x00,0x02,0x00,0x00,0x00,0x00,0x0c,0x00,0x00,0x04,
0x00,0x00,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00
};

// === Global Object Definitions ===
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE); 
U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2_small(U8G2_R0, U8X8_PIN_NONE); 
QuadratureEncoder encoder; // Definition
VerticalListAnimation mainMenuAnim;
CarouselAnimation subMenuAnim;
VerticalListAnimation wifiListAnim; 

// === Global Variable Definitions ===
MenuState currentMenu = MAIN_MENU;
int menuIndex = 0;
int maxMenuItems = 0;
int mainMenuSavedIndex = 0;
int toolsCategoryIndex = 0;
int gridCols = 2;
int targetGridScrollOffset_Y = 0;
float currentGridScrollOffset_Y_anim = 0.0f;
uint8_t pcf0Output = 0xFF & ~((1 << 6) | (1 << 7));

float batReadings[BAT_SAMPLES] = {0};
int batIndex = 0;
bool batInitialized = false;
float lastValidBattery = 4.0f;
unsigned long lastBatteryCheck = 0;
float currentBatteryVoltage = 4.0f;
bool batteryNeedsUpdate = true;
bool isCharging = false;

bool vibrationOn = false;
bool laserOn = false;

float gridItemScale[MAX_GRID_ITEMS];
float gridItemTargetScale[MAX_GRID_ITEMS];
unsigned long gridItemAnimStartTime[MAX_GRID_ITEMS];
bool gridAnimatingIn = false;
char marqueeText[40];
int marqueeTextLenPx = 0;
float marqueeOffset = 0;
unsigned long lastMarqueeTime = 0;
bool marqueeActive = false;
bool marqueePaused = false;
unsigned long marqueePauseStartTime = 0;
bool marqueeScrollLeft = true;
char SBUF[32];
bool btnPress0[8] = {false};
bool btnPress1[8] = {false};

// Wi-Fi Related Global Variable DEFINITIONS
WifiNetwork scannedNetworks[MAX_WIFI_NETWORKS];
int foundWifiNetworksCount = 0;
int wifiMenuIndex = 0;
bool wifiIsScanning = false;
unsigned long lastWifiScanCheckTime = 0;
float currentWifiListScrollOffset_Y_anim = 0.0f;
int targetWifiListScrollOffset_Y = 0;

char currentSsidToConnect[33];      // <--- NEW DEFINITION
char wifiPasswordInput[PASSWORD_MAX_LEN + 1]; // <--- NEW DEFINITION
int wifiPasswordInputCursor = 0;    // <--- NEW DEFINITION
bool selectedNetworkIsSecure = false; // <--- NEW DEFINITION
bool wifiHardwareEnabled = false; // <--- ADDED DEFINITION, default to off

// Keyboard related globals
KeyboardLayer currentKeyboardLayer = KB_LAYER_LOWERCASE; // <--- NEW DEFINITION
int keyboardFocusRow = 0;               // <--- NEW DEFINITION
int keyboardFocusCol = 0;               // <--- NEW DEFINITION
bool capsLockActive = false;            // <--- NEW DEFINITION

// Timer for connection attempt / info display
unsigned long wifiStatusMessageTimeout = 0; // <--- NEW DEFINITION

void setup() {
  Serial.begin(115200);
  Wire.begin();

  selectMux(0);
  writePCF(PCF0_ADDR, pcf0Output);

  // Initialize SD Card first, as other modules might depend on it
  if (setupSdCard()) { // From sd_card_manager.h
    Serial.println("SD Card initialized successfully.");
    // Optional: Perform a quick test or list root directory
    listDirectory("/", 0); 
    // testSdFileIO("/test.txt"); // Uncomment to run I/O test on boot
  } else {
    Serial.println("SD Card initialization failed!");
    // Potentially set a global flag or display an error message on screen
  }


  analogReadResolution(12);
  #if defined(ESP32) || defined(ESP_PLATFORM)
  // analogSetPinAttenuation((uint8_t)ADC_PIN, ADC_11DB);
  #endif
  setupBatteryMonitor();
  setupInputs();
  setupWifi(); // From wifi_manager

  selectMux(MUX_CHANNEL_MAIN_DISPLAY);
  u8g2.begin();
  u8g2.enableUTF8Print();

  selectMux(MUX_CHANNEL_SECOND_DISPLAY);
  u8g2_small.begin();
  u8g2_small.enableUTF8Print();
  u8g2_small.clearBuffer();
  u8g2_small.setFont(u8g2_font_5x7_tf);
  u8g2_small.drawStr(0,7,"Kiva Aux");
  u8g2_small.sendBuffer();
  delay(500);

  selectMux(MUX_CHANNEL_MAIN_DISPLAY);
  // ... (Splash screen animation code - existing) ...
    int progressBarY = im_height - 12;
    int progressBarHeight = 7;
    int progressBarWidth = im_width - 40;
    int progressBarX = (im_width - progressBarWidth) / 2;
    int numSteps = 25;
    int stepDelay = 80;
    for (int i = 0; i <= numSteps; i++) {
        u8g2.firstPage();
        do {
        if (sizeof(im_bits) > 1) {
            u8g2.drawXBM(0, 0, im_width, im_height, im_bits);
        } else {
            u8g2.setFont(u8g2_font_ncenB10_tr);
            u8g2.drawStr((128-u8g2.getStrWidth("KIVA"))/2, 35, "KIVA");
        }
        u8g2.drawRFrame(progressBarX, progressBarY, progressBarWidth, progressBarHeight, 1);
        int currentFillWidth = (progressBarWidth - 2) * i / numSteps;
        if (currentFillWidth > 0) {
            u8g2.drawRBox(progressBarX + 1, progressBarY + 1, currentFillWidth, progressBarHeight - 2, 0);
        }
        } while (u8g2.nextPage());
        delay(stepDelay);
    }

  initializeCurrentMenu();
  wifiPasswordInput[0] = '\0'; // Ensure password buffer is empty initially
}

void loop() {
  updateInputs();

  // --- Wi-Fi Auto Shutdown Logic ---
  if (wifiHardwareEnabled && WiFi.status() != WL_CONNECTED) {
    // If Wi-Fi hardware is on but not connected...
    bool inWifiMenu = (currentMenu == WIFI_SETUP_MENU || 
                       currentMenu == WIFI_PASSWORD_INPUT || 
                       currentMenu == WIFI_CONNECTING || 
                       currentMenu == WIFI_CONNECTION_INFO);
    
    if (!inWifiMenu && !wifiIsScanning) { 
      // Not in a Wi-Fi specific menu and not actively scanning
      
      // Get the current connection/scan status using the getter function
      WifiConnectionStatus currentStatus = getCurrentWifiConnectionStatus(); // From wifi_manager.h

      if (currentStatus != WIFI_CONNECTING_IN_PROGRESS && currentStatus != KIVA_WIFI_SCAN_RUNNING) {
           // This block was intended for updating a timer, but for a simple aggressive shutdown,
           // the condition below is sufficient. If a grace period is added, this is where
           // 'lastWifiActivityOrConnectAttempt' would be updated.
      }

      // If not actively trying to connect or scan, turn off Wi-Fi.
      if (currentStatus != WIFI_CONNECTING_IN_PROGRESS && currentStatus != KIVA_WIFI_SCAN_RUNNING) {
          Serial.println("Loop: Wi-Fi hardware enabled, not connected, not in Wi-Fi menu, not actively trying. Disabling Wi-Fi hardware.");
          setWifiHardwareState(false); // This function will handle WiFi.disconnect, WiFi.mode(WIFI_OFF), etc.
                                       // It also updates wifiHardwareEnabled, currentConnectedSsid, and wifiStatusString.
      }
    }
  }


  if (currentMenu == WIFI_SETUP_MENU && wifiIsScanning) {
    if (millis() - lastWifiScanCheckTime > WIFI_SCAN_CHECK_INTERVAL) {
      int scanCompleteResult = WiFi.scanComplete(); 

      if (scanCompleteResult >= 0) { 
        wifiIsScanning = false; 
        checkAndRetrieveWifiScanResults(); 
        initializeCurrentMenu();
        wifiMenuIndex = 0;
        targetWifiListScrollOffset_Y = 0;
        currentWifiListScrollOffset_Y_anim = 0;
        if (currentMenu == WIFI_SETUP_MENU) { 
             wifiListAnim.setTargets(wifiMenuIndex, maxMenuItems);
        }
      } else if (scanCompleteResult == WIFI_SCAN_FAILED) { 
        Serial.println("Loop: Scan failed as per WiFi.scanComplete()");
        wifiIsScanning = false;
        foundWifiNetworksCount = 0; 
        checkAndRetrieveWifiScanResults(); 
        initializeCurrentMenu(); 
        wifiMenuIndex = 0; targetWifiListScrollOffset_Y = 0; currentWifiListScrollOffset_Y_anim = 0;
        if(currentMenu == WIFI_SETUP_MENU) wifiListAnim.setTargets(wifiMenuIndex, maxMenuItems);
      } else { // WIFI_SCAN_RUNNING (-1), scan is still ongoing
        // Do nothing, wait for next check interval
      }
      lastWifiScanCheckTime = millis();
    }
  } else if (currentMenu == WIFI_CONNECTING) {
      WifiConnectionStatus status = checkWifiConnectionProgress(); // From wifi_manager.h
      if (status != WIFI_CONNECTING_IN_PROGRESS) {
          currentMenu = WIFI_CONNECTION_INFO;
          wifiStatusMessageTimeout = millis() + 3000; // Display result for 3 seconds
          initializeCurrentMenu();
          // If connection failed and it was a secure network, the fail count was updated.
          // If succeeded, fail count was reset.
          // The known network list was updated by addOrUpdateKnownNetwork if a new password was entered.
      }
  } else if (currentMenu == WIFI_CONNECTION_INFO) {
      if (millis() > wifiStatusMessageTimeout) {
          WifiConnectionStatus lastStatus = getCurrentWifiConnectionStatus(); // From wifi_manager.h
          if (lastStatus == WIFI_CONNECTED_SUCCESS) {
              currentMenu = WIFI_SETUP_MENU; // Go back to the (updated) list
              // Re-check scan results to potentially reorder list with connected on top
              // if not already handled by checkAndRetrieveWifiScanResults being called
              // after successful connection logic.
              // For now, initializeCurrentMenu will refresh the list display.
          } else if (selectedNetworkIsSecure && (lastStatus == WIFI_FAILED_WRONG_PASSWORD || lastStatus == WIFI_FAILED_TIMEOUT)) {
              // If connection failed for secure network (wrong pass or timeout), go back to password input
              // This gives the user another chance or they can back out.
              // Check fail count again. If it's now >= MAX_WIFI_FAIL_ATTEMPTS, it will prompt.
              // If it's a new network, it won't have a high fail count yet from this single attempt.
              KnownWifiNetwork* net = findKnownNetwork(currentSsidToConnect);
              if (net && net->failCount >= MAX_WIFI_FAIL_ATTEMPTS) {
                  currentMenu = WIFI_PASSWORD_INPUT; // Prompt again
              } else {
                 // If fail count is not yet maxed out OR it was a timeout on a first attempt with new password
                 // (and we want to give another chance without re-entering password),
                 // or if it's an open network that failed to connect.
                 // For simplicity, after any failure, go back to the Wi-Fi list.
                 // The user can then choose to re-select and try again (which might re-prompt for pass if needed).
                  currentMenu = WIFI_SETUP_MENU;
              }
          } else { // Other failures, or open network failure
              currentMenu = WIFI_SETUP_MENU;
          }
          initializeCurrentMenu();
      }
  }


  if (btnPress1[NAV_OK] || btnPress0[ENC_BTN]) {
    if (btnPress1[NAV_OK]) btnPress1[NAV_OK] = false;
    if (btnPress0[ENC_BTN]) btnPress0[ENC_BTN] = false;
    if (currentMenu != WIFI_PASSWORD_INPUT) { // Password input OK is handled by keyboard logic
        handleMenuSelection();
    }
  }

  if (btnPress1[NAV_BACK]) {
    btnPress1[NAV_BACK] = false;
    handleMenuBackNavigation();
  }

  // Clear one-shot button presses (except encoder button if used by keyboard)
  for (int i = 0; i < 8; ++i) {
      if (currentMenu == WIFI_PASSWORD_INPUT && i == ENC_BTN) {
          // Don't clear ENC_BTN if in password input, as it's used for key presses there
      } else {
          btnPress0[i] = false;
      }
      // Clear NAV_OK and NAV_BACK as they are handled above or by keyboard input
      if (i != NAV_OK && i != NAV_BACK) {
         // For other PCF1 buttons, if they are not meant to be one-shot outside of keyboard/scrolling,
         // clear them here. Otherwise, their specific handlers should clear them.
         // For now, assume other NAV buttons (A, B, etc.) are not used as one-shot general presses.
         // btnPress1[i] = false; // Uncomment if other NAV buttons are general one-shot
      }
  }
  // Specifically clear NAV_UP, NAV_DOWN, NAV_LEFT, NAV_RIGHT from btnPress1,
  // as their primary action (scrolling) is continuous or handled by initial press.
  // One-shot press flags for these are mostly for initiating hold/repeat.
  btnPress1[NAV_UP] = false;
  btnPress1[NAV_DOWN] = false;
  btnPress1[NAV_LEFT] = false;
  btnPress1[NAV_RIGHT] = false;


  drawUI();
  delay(16); // Approx 60 FPS target
}