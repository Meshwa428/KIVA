**Role:** You are an expert C++ software architect specializing in embedded systems and real-time applications. You are tasked with refactoring a complex PlatformIO project for an ESP32-S3 device to improve its architecture, efficiency, and maintainability.

**Project Context:**
The project is "KIVA," a handheld security tool. I have provided you with the complete source tree, several key source files, and crucial design documents (`ardhitecture_shift.md`, `future_implementations.md`, `new_features.md`).

**Core Problem to Address: The "God Object" Anti-Pattern**

The central `App` class (`App.h`, `App.cpp`) has become a "God Object." It directly contains an instance of every single manager and service class in the project (e.g., `Jammer jammer_;`, `EvilPortal evilPortal_;`, `MusicPlayer musicPlayer_`, etc.).

This has led to severe architectural issues:
1.  **Massive Boot-Time Overhead:** The `App::setup()` method initializes *every single feature* at boot via the `bootTasks` vector. This is incredibly inefficient, consuming significant time and memory for services that may never be used in a given session.
2.  **High Static Memory Usage:** Because every manager is a member of the `App` singleton, their memory is allocated for the entire lifetime of the application, even when they are idle.
3.  **Tight Coupling:** Every component that needs to interact with another (e.g., a menu starting a WiFi attack) must do so through a pointer to the `App` object (`app->getJammer().start()`). This makes the system rigid, hard to test, and difficult to reason about. The `App` class knows everything about everyone.

**Your Primary Goal: Implement a Service-Oriented, On-Demand Architecture**

Your task is to refactor the KIVA project to dismantle the `App` God Object. The new architecture must adhere to the following principles:

1.  **Lazy Initialization:** Services and managers should only be instantiated and initialized the *first time* they are actually requested. They should not be set up at boot unless absolutely necessary.
2.  **On-Demand Access:** Components should be able to get a pointer to any service they need from a central, decoupled provider, without going through the `App` class.
3.  **Resource Management:** When a service is finished with its task (e.g., a user exits the "Jamming" screen), it should release any exclusive hardware resources it holds and its core logic should become idle to conserve power and CPU cycles.

**Proposed Architecture: The Service Locator Pattern**

You will introduce a new central component, the **Service Locator** (we'll call it `ServiceManager`), which will be responsible for creating, managing, and providing access to all other services.

This approach is an evolution of the ideas presented in the provided `ardhitecture_shift.md` document, which you must treat as a key source of architectural intent.

**Detailed Refactoring Instructions:**

Follow these steps precisely.

**Step 1: Create the `ServiceManager` (Service Locator)**

Create a new pair of files: `include/ServiceManager.h` and `src/ServiceManager.cpp`.

This class will be a singleton that uses templates for type-safe service retrieval. It will use a `std::map` to store pointers to singleton service instances, creating them only on the first request.

**`include/ServiceManager.h` should look like this:**
```cpp
#ifndef SERVICE_MANAGER_H
#define SERVICE_MANAGER_H

#include <map>
#include <memory>
#include <string>
#include <typeindex>
#include "Logger.h"

// Forward declare App to resolve circular dependency
class App;

// Base class for all services
class IService {
public:
    virtual ~IService() = default;
    // A setup method for services that need early, non-hardware initialization
    virtual void setup(App* app) {}
    // An initialize method for heavy, on-demand hardware setup
    virtual bool initialize() { return true; }
};

class ServiceManager {
public:
    static ServiceManager& getInstance();

    // The core template method to get a service
    template<typename T>
    static T& get() {
        auto& instance = getInstance();
        std::type_index typeIndex(typeid(T));

        if (instance.services_.find(typeIndex) == instance.services_.end()) {
            LOG(LogLevel::INFO, "SERVICE_MANAGER", "Creating new service: %s", typeid(T).name());
            instance.services_[typeIndex] = std::make_unique<T>();
            // Pass the App context to services that need it for core functions.
            instance.services_[typeIndex]->setup(&App::getInstance());
        }
        return static_cast<T&>(*instance.services_[typeIndex]);
    }

    // Disable copy/assignment
    ServiceManager(const ServiceManager&) = delete;
    void operator=(const ServiceManager&) = delete;

private:
    ServiceManager() = default;
    std::map<std::type_index, std::unique_ptr<IService>> services_;
};

#endif // SERVICE_MANAGER_H
```
*You do not need to create `src/ServiceManager.cpp` as the template implementation is fully in the header.*

**Step 2: Refactor All Managers to be Services**

Modify every manager class (e.g., `Jammer`, `EvilPortal`, `MusicPlayer`, `ConfigManager`, etc.) to inherit from the new `IService` base class.

*   **Example (`Jammer.h`):**
    *   **Before:** `class Jammer { ... };`
    *   **After:** `class Jammer : public IService { ... };`
*   Ensure all manager classes have a public default constructor.
*   The `setup(App* app)` method in each manager is now inherited from `IService` and will be called automatically by the `ServiceManager` upon creation.

**Step 3: Dismantle the `App` God Object**

This is the most critical step.

1.  **In `App.h`:**
    *   Remove *every single manager member variable*. Delete `Jammer jammer_;`, `BeaconSpammer beaconSpammer_;`, `Deauther deauther_;`, `EvilPortal evilPortal_;`, `DuckyScriptRunner duckyRunner_;`, etc.
    *   Remove all corresponding `get...()` methods (`getJammer()`, `getEvilPortal()`, etc.).
    *   Remove the forward declarations and includes for all the manager classes you just deleted. The `App` class should no longer know about them directly.

2.  **In `App.cpp`:**
    *   Remove all the deleted manager members from the constructor's initializer list.
    *   Go through the entire file and replace every call like `jammer_.start()` or `app->getEvilPortal().stop()` with the new Service Locator syntax: `ServiceManager::get<Jammer>().start()` or `ServiceManager::get<EvilPortal>().stop()`.
    *   **Crucially, overhaul `App::setup()`:**
        *   The `bootTasks` vector must be completely eliminated.
        *   The new `App::setup()` should only initialize the absolute bare minimum required for the system to start and draw a UI. This includes:
            *   `hardware_.setup()`
            *   `ServiceManager::get<ConfigManager>()` (to load settings early)
            *   `Logger::getInstance().setup()`
            *   `ServiceManager::get<RtcManager>()`
        *   **Do not** call `setup()` or `initialize()` for any other service here. They will be initialized on-demand by the `ServiceManager`.

**Step 4: Update Service Usage in Menus and Other Components**

Search through the entire codebase, especially in the `src` directory (menu implementations, data sources), and replace all old calls that used the `App` object to access managers.

*   **Example (`JammingActiveMenu.cpp`):**
    *   **Before:** `app->getJammer().start(...)`
    *   **After:** `ServiceManager::get<Jammer>().start(...)`

*   **Example (`DeauthActiveMenu.cpp`):**
    *   **Before:** `auto& deauther = app->getDeauther();`
    *   **After:** `auto& deauther = ServiceManager::get<Deauther>();`

**Step 5: Implement On-Demand Hardware Initialization**

For services that perform heavy, one-time hardware setup (like initializing a library or configuring complex peripherals), use the `initialize()` method.

*   Modify the service's primary `start()` method to check a flag. If it's the first time being run, call `initialize()`.
*   **Example (`MusicPlayer.cpp`):** The `allocateResources()` method is a perfect candidate to be moved into an `initialize()` method. The `startQueuedPlayback()` function should be modified to call `initialize()` if it hasn't been called before.

```cpp
// In MusicPlayer.h
class MusicPlayer : public IService {
private:
    bool initialized_ = false;
    // ...
};

// In MusicPlayer.cpp
bool MusicPlayer::initialize() {
    if (initialized_) return true;
    LOG(LogLevel::INFO, "PLAYER", "First use: Initializing audio resources...");
    // Move all logic from allocateResources() here.
    // ...
    initialized_ = true; // Set flag on success
    return true;
}

void MusicPlayer::startQueuedPlayback() {
    if (!initialized_ && !initialize()) {
        LOG(LogLevel::ERROR, "PLAYER", "Failed to initialize on demand.");
        return;
    }
    // ... rest of the function
}
```

**Final Output:**
Provide the complete, modified code for all affected files. Ensure the new architecture is consistently applied throughout the project. The final result should be a system where the `App` class is lean, boot time is significantly faster, and services are loaded lazily, just-in-time, as the user navigates the UI.